<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Memleax : detects memory leak of running process">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Memleax</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/WuBingzheng/memleax">View on GitHub</a>

          <h1 id="project_title">Memleax</h1>
          <h2 id="project_tagline">detects memory leak of running process</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/WuBingzheng/memleax/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/WuBingzheng/memleax/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="memleax" class="anchor" href="#memleax" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>memleax</h2>

<p><code>memleax</code> detects memory leak of a <em>running</em> process.</p>

<h2>
<a id="why-write-this" class="anchor" href="#why-write-this" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>why write this</h2>

<p>Once I met a memory leak problem in production environment.
The process began memory leak after long-time running. If using current
memory debuggers, such as <code>Valgrind</code>, I have to restart the target process
and wait for several days again. Besides it impacts the target process
much for several days, which is not good for production environment.</p>

<p>So I need a tool to debug a running process without restarting it.
I searched the internet but didn't find one. Then I wrote such a tool myself.</p>

<p>Hope this is useful for others.</p>

<h2>
<a id="how-it-works" class="anchor" href="#how-it-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>how it works</h2>

<p><code>memleax</code> attachs a running process, hooks memory allocate/free APIs,
records all memory blocks, and reports the blocks which live longer
than 5 seconds (you can change this time by -e option) in real time.</p>

<p>It is very <em>convenient</em> to use, and suitable for production environment.
There is no need to recompile the program or restart the target process.
You run <code>memleax</code> to monitor the target process, wait for the real-time memory
leak report, and then kill it (e.g. by Ctrl-C) to stop monitoring.</p>

<p>NOTE: Since <code>memleax</code> does not run along with the whole life of target
process, it assumes the long-live memory blocks are memory leak.
Downside is you have to set the expire threshold by -e option according
to your scenarios; while the upside is the memory allocation for process
initialization is skipped, besides of the convenience.</p>

<h2>
<a id="performace-influence" class="anchor" href="#performace-influence" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>performace influence</h2>

<p>Because target progress's each memory allocation/free API invokes a TRAP, the
performance influence depends on how often the target program calls memory
APIs.
For example, it impacts lightly to nginx with HTTP, while heavily with HTTPS,
because OpenSSL calls malloc seriously.</p>

<p>Although performance influence is worthy of consideration, since <code>memleax</code> is
run to attach the target progress only when you certain it is in memory leak,
and stopped after real-time memory leak report, so it is not need to attach
the target progress for long time.</p>

<h2>
<a id="difference-with-valgrind" class="anchor" href="#difference-with-valgrind" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>difference with Valgrind</h2>

<ul>
<li><p><code>Valgrind</code> starts target process, while <code>memleax</code> attachs a running process;</p></li>
<li><p><code>Valgrind</code> gives memory leak report on quiting, while <code>memleax</code> assumes
that long-living memory blocks are leaks, so it reports in real time;</p></li>
<li><p><code>Valgrind</code> runs target process on its virtual CPU, which makes it slow.
While <code>memleax</code> hooks memory APIs, which <em>maybe</em> less slow, if the target process
call memory APIs not often.</p></li>
<li><p><code>Valgrind</code> debugs kinds of memory bugs, while <code>memleax</code> is lightweight and
only detects memory leak.</p></li>
</ul>

<p>In summary, I think <code>Valgrind</code> is more powerful, while <code>memleax</code> is more
convenient and suitable for production environment.</p>

<h2>
<a id="environment" class="anchor" href="#environment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>environment</h2>

<ul>
<li>GNU/Linux, x86_64</li>
<li>FreeBSD, amd64</li>
</ul>

<h2>
<a id="requirement" class="anchor" href="#requirement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>requirement</h2>

<ul>
<li>libunwind</li>
<li>libdwarf, if you do not have this, set <code>--disable-libdwarf</code> to <code>configure</code> to
disable it, and you will not see file name and line number in backtrace.</li>
<li>elfutils-libelf, on GNU/Linux, while FreeBSD has libelf already.</li>
</ul>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>usage</h2>

<p>To detect a running process:</p>

<pre><code>$ memleax [options] &lt;target-pid&gt;
</code></pre>

<p>then <code>memleax</code> monitors the target process, and will report memory leak in real time.</p>

<p>It stops monitoring and quits on:</p>

<ul>
<li>the target process quits,</li>
<li>
<code>memleax</code> exits (by SIGKILL or Ctrl-C), or</li>
<li>the number of leaked memory blocks at one CallStack exceeds 1000 (change this threshold by -n option).</li>
</ul>

<p>After quiting, it also gives statistics for the CallStacks with memory leak.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Memleax maintained by <a href="https://github.com/WuBingzheng">WuBingzheng</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
