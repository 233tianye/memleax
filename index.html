<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Memleax : detects memory leak of running process">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Memleax</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/WuBingzheng/memleax">View on GitHub</a>

          <h1 id="project_title">Memleax</h1>
          <h2 id="project_tagline">detects memory leak of running process</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/WuBingzheng/memleax/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/WuBingzheng/memleax/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="memleax" class="anchor" href="#memleax" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>memleax</h2>

<p><code>memleax</code> debugs memory leak of a <em>running</em> process by attaching it,
without recompiling or restarting.</p>

<h2>
<a id="status" class="anchor" href="#status" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>status</h2>

<p>Stable and completed.</p>

<p><code>memleax</code> is a tool with single and clear aim. There is
no known bug to fix and no new feature to add by now.</p>

<p>However if you get any new feature or bug, please report
to <a href="https://github.com/WuBingzheng/memleax">GitHub</a>,
or mail to <a href="mailto:wubingzheng@gmail.com">wubingzheng@gmail.com</a>.</p>

<h2>
<a id="how-it-works" class="anchor" href="#how-it-works" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>how it works</h2>

<p><code>memleax</code> debugs memory leak of a running process by attaching it.
It hooks the target process's invocation of memory allocation and free,
and reports the memory blocks which live long enough as memory leak, in real time.
The default expire threshold is 10 seconds, however you should always
set it by <code>-e</code> option according to your scenarios.</p>

<p>It is very <em>convenient</em> to use, and suitable for production environment.
There is no need to recompile the program or restart the target process.
You run <code>memleax</code> to monitor the target process, wait for the real-time memory
leak report, and then kill it (e.g. by Ctrl-C) to stop monitoring.</p>

<p><code>memleax</code> follows new threads, but not forked processes.
If you want to debug multiple processes, just run multiple memleax.

<h2>
<a id="performance-impact" class="anchor" href="#performance-impact" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>performance impact</h2>

<p>Because target process's each invocation of memory allocation and free makes
a TRAP, the performance impact depends on the frequency of memory invocation
in target process.</p>

<p>For example, it impacts lightly to <code>nginx</code> with HTTP, while heavily with HTTPS,
because <code>OpenSSL</code> calls <code>malloc()</code> terribly.</p>

<h2>
<a id="difference-from-valgrind" class="anchor" href="#difference-from-valgrind" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>difference from Valgrind</h2>

<ul>
<li><p><code>Valgrind</code> starts target process, while <code>memleax</code> attaches to a running process;</p></li>
<li><p><code>Valgrind</code> gives memory leak report on quitting, while <code>memleax</code> assumes
that long-living memory blocks are leaks, so it reports in real time;</p></li>
<li><p><code>Valgrind</code> reports all unfreed memory include program init, while <code>memleax</code>
reports only after attaching, skipping the init phase;</p></li>
<li><p><code>Valgrind</code> runs target process on its virtual CPU, which makes it slow.
While <code>memleax</code> hooks memory APIs, which <em>may be</em> less slow if the target process
call memory APIs not often.</p></li>
<li><p><code>Valgrind</code> debugs kinds of memory bugs, while <code>memleax</code> is lightweight and
only detects memory leak.</p></li>
</ul>

<p>In summary, I think <code>Valgrind</code> is more powerful, while <code>memleax</code> is more
convenient and suitable for production environment.</p>

<h2>
<a id="licence" class="anchor" href="#licence" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>licence</h2>

<p>GPLv2</p>

<h2>
<a id="os-machine" class="anchor" href="#os-machine" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>OS-machine</h2>

<ul>
<li>GNU/Linux-x86_64, tested on CentOS 7.2 and Ubuntu 16.04</li>
<li>FreeBSD-amd64, tested on FreeBSD 10.3</li>
</ul>

<h2>
<a id="install-by-package" class="anchor" href="#install-by-package" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>install by package</h2>

<p>There are DEB and RPM packages for
<a href="https://github.com/WuBingzheng/memleax/releases">releases</a>.</p>

<p>For Arch Linux users, `memleax` is available in AUR. Thanks to jelly.</p>

<p>For FreeBSD users, `memleax` is available in FreeBSD Ports collection.
Thanks to tabrarg.</p>

<p>I tried to submit `memleax` to Fedora <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1417531">ELEP</a>,
but failed. Any help is welcomed.</p>

<h2>
<a id="build-from-source" class="anchor" href="#build-from-source" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>build from source</h2>

<p>The development packages of the following libraries are required:</p>

<ul>
<li><code>libunwind</code></li>
<li><code>libelf</code></li>
<li>
<code>libdw</code> or <code>libdwarf</code>. <code>libdw</code> is preferred. They are used to read dwarf debug-line
information. If you do not have them neither, set <code>--disable-debug_line</code> to
<code>configure</code> to disable it. As a result you will not see file name and line
number in backtrace.</li>
</ul>

<p>These packages may have different names in different distributions, such as
<code>libelf</code> may names <code>libelf</code>, <code>elfutils-libelf</code>, or <code>libelf1</code>.</p>

<p>NOTE: On FreeBSD 10.3, there are built-in <code>libelf</code> and <code>libdwarf</code> already.
However another <code>libelf</code> and <code>libdwarf</code> still can be installed by <code>pkg</code>.
<code>memleax</code> works with <code>built-in libelf</code> and <code>pkg libdwarf</code>. So you should
install <code>libdwarf</code> by <code>pkg</code>, and must not install <code>libelf</code> by <code>pkg</code>.</p>

<p>After all required libraries are installed, run</p>

<pre><code>$ ./configure
$ make
$ sudo make install
</code></pre>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>usage</h2>

<h3>
<a id="start" class="anchor" href="#start" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>start</h3>

<p>To debug a running process, run:</p>

<pre><code>$ memleax [options] &lt;target-pid&gt;
</code></pre>

<p>then <code>memleax</code> begins to monitor the target process, and report memory leak in real time.</p>

<p>You should always set expire time by <code>-e</code> options according to your scenarios.
For example, if you are debugging an HTTP server with keepalive, and there are
connections last for more than 5 minutes, you should set <code>-e 360</code> to cover it.
If your program is expected to free every memory in 1 second, you should set <code>-e 2</code>
to get report in time.</p>

<h3>
<a id="wait-and-check-the-report" class="anchor" href="#wait-and-check-the-report" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>wait and check the report</h3>

<p>The memory blocks live longer than the threshold, are showed as:</p>

<pre><code>CallStack[3]: memory expires with 101 bytes, backtrace:
    0x00007fd322bd8220  libc-2.17.so  malloc()+0
    0x000000000040084e  test  foo()+14  foo.c:12
    0x0000000000400875  test  bar()+37  bar.c:20
    0x0000000000400acb  test  main()+364  test.c:80
</code></pre>

<p><code>CallStack[3]</code> is the ID of CallStack where memory leak happens.</p>

<p>The backtrace is showed only on the first time, while it only shows the
ID and counter if expiring again:</p>

<pre><code>CallStack[3]: memory expires with 101 bytes, 2 times again
</code></pre>

<p>If the expired memory block is freed later, it shows:</p>

<pre><code>CallStack[6]: expired-memory frees after 10 seconds
</code></pre>

<p>If there are too many expired-memory-blocks are freed on one CallStack,
this CallStack will not be showed again:</p>

<pre><code>Warning: too many expired-free at CallStack[6]. will not show this CallStack later
</code></pre>

<p>When you think you have found the answer, stop the debug.</p>

<h3>
<a id="stop" class="anchor" href="#stop" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>stop</h3>

<p><code>memleax</code> quits on:</p>

<ul>
<li>you stop it, by Ctrl-C or kill,</li>
<li>the target process quits,</li>
<li>too many leaks at one CallStack (option -m), or</li>
<li>too many CallStacks with memory leak (option -c).</li>
</ul>

<p>After quitting, it also gives statistics for the CallStacks with memory leak:</p>

<pre><code>CallStack[3]: may-leak=20 (2020 bytes)
    expired=20 (2020 bytes), free_expired=0 (0 bytes)
    alloc=20 (2020 bytes), free=0 (0 bytes)
    freed memory live time: min=0 max=0 average=0
    un-freed memory live time: max=20
    0x00007fd322bd8220  libc-2.17.so  malloc()+0
    0x000000000040084e  test  foo()+14  foo.c:12
    0x0000000000400875  test  bar()+37  bar.c:20
    0x0000000000400acb  test  main()+364  test.c:80
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Memleax maintained by <a href="https://github.com/WuBingzheng">WuBingzheng</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
