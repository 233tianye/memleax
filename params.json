{
  "name": "Memleax",
  "tagline": "detects memory leak of running process",
  "body": "## memleax\r\n\r\n`memleax` detects memory leak of a *running* process.\r\n\r\n`memleax` attachs a running process, hooks memory allocate/free APIs,\r\nrecords all memory blocks, and reports the blocks which live longer\r\nthan 5 seconds (you can change this time by -e option) in real time.\r\n\r\nSo it is very *convenient* to use.\r\nThere is no need to recompile the program or restart the target process.\r\nYou run `memleax` to monitor the target process, wait the real-time memory\r\nleak report, and kill it (e.g. by Ctrl-C) to stop monitoring.\r\n\r\nNOTE: Since `memleax` does not run along with the whole life of target\r\nprocess, it assumes the long-live memory blocks are memory leak.\r\nDownside is you have to set the expire threshold by -e option according\r\nto your scenarios; while the upside is the memory allocation for process\r\ninitialization is skipped, besides of the convenience.\r\n\r\n\r\n## environment\r\n\r\n* GNU/Linux, x86_64\r\n* FreeBSD, amd64\r\n\r\n\r\n## usage\r\n\r\nTo detect a running process:\r\n\r\n    $ memleax [options] <target-pid>\r\n\r\nthen `memleax` monitors the target process, and will report memory leak in real time.\r\n\r\nIt stops monitoring and quits on:\r\n\r\n* the target process quits,\r\n* stop `memleax` (by SIGKILL or Ctrl-C), or\r\n* the number of leaked memory blocks at one CallStack exceeds 1000 (change this threshold by -n option).\r\n\r\nAfter quiting, it also gives statistics for the CallStacks with memory leak.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}