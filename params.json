{
  "name": "Memleax",
  "tagline": "detects memory leak of running process",
  "body": "## memleax\r\n\r\n`memleax` debugs memory leak of a *running* process by attaching it,\r\nwithout recompiling or restarting.\r\n\r\n\r\n## status\r\n\r\nStable and completed.\r\n\r\n`memleax` is a tool with single and clear aim. There is\r\nno known bug to fix and no new feature to add by now.\r\n\r\nHowever if you get any new feature or bug, please report\r\nto [GitHub] (https://github.com/WuBingzheng/memleax),\r\nor mail to <mailto:wubingzheng@gmail.com>.\r\n\r\n\r\n## how it works\r\n\r\n`memleax` attaches to a running process, hooks memory allocate/free APIs,\r\nrecords all memory blocks, and reports the blocks which live longer\r\nthan 10 seconds (you can change this time by -e option) in real time.\r\n\r\nIt is very *convenient* to use, and suitable for production environment.\r\nThere is no need to recompile the program or restart the target process.\r\nYou run `memleax` to monitor the target process, wait for the real-time memory\r\nleak report, and then kill it (e.g. by Ctrl-C) to stop monitoring.\r\n\r\nNOTE: Since `memleax` does not run along with the whole life of target\r\nprocess, it assumes the long-lived memory blocks are memory leaks.\r\n\r\n\r\n## performance impact\r\n\r\nBecause target process's each memory allocation/free API invokes a TRAP, the\r\nperformance impact depends on how often the target program calls memory\r\nAPIs.\r\nFor example, it impacts lightly to nginx with HTTP, while heavily with HTTPS,\r\nbecause OpenSSL calls malloc terribly.\r\n\r\nAlthough performance impact is worthy of consideration, since `memleax` is\r\nrun to attach to the target process only when you are certain it is in memory leak,\r\nand stopped after real-time memory leak report, it is not needed to attach to\r\nthe target process for long time.\r\n\r\n\r\n## difference from Valgrind\r\n\r\n+ `Valgrind` starts target process, while `memleax` attaches to a running process;\r\n\r\n+ `Valgrind` gives memory leak report on quitting, while `memleax` assumes\r\nthat long-living memory blocks are leaks, so it reports in real time;\r\n\r\n+ `Valgrind` reports all unfreed memory include program init, while `memleax`\r\nreports only after attaching, skipping the init phase;\r\n\r\n+ `Valgrind` runs target process on its virtual CPU, which makes it slow.\r\nWhile `memleax` hooks memory APIs, which *may be* less slow if the target process\r\ncall memory APIs not often.\r\n\r\n+ `Valgrind` debugs kinds of memory bugs, while `memleax` is lightweight and\r\nonly detects memory leak.\r\n\r\nIn summary, I think `Valgrind` is more powerful, while `memleax` is more\r\nconvenient and suitable for production environment.\r\n\r\n\r\n## licence\r\n\r\nGPLv2\r\n\r\n\r\n## OS-machine\r\n\r\n+ GNU/Linux-x86_64, tested on CentOS 7.2 and Ubuntu 16.04\r\n+ FreeBSD-amd64, tested on FreeBSD 10.3\r\n\r\n\r\n## build from source\r\n\r\nThe development packages of the following libraries are required:\r\n\r\n+ `libunwind`\r\n+ `libelf`\r\n+ `libdw` or `libdwarf`. `libdw` is preferred. They are used to read dwarf debug-line\r\ninformation. If you do not have them neither, set `--disable-debug_line` to\r\n`configure` to disable it. As a result you will not see file name and line\r\nnumber in backtrace.\r\n\r\nThese packages may have different names in different distributions, such as\r\n`libelf` may names `libelf`, `elfutils-libelf`, or `libelf1`.\r\n\r\nNOTE: On FreeBSD 10.3, there are built-in `libelf` and `libdwarf` already.\r\nHowever another `libelf` and `libdwarf` still can be installed by `pkg`.\r\n`memleax` works with `built-in libelf` and `pkg libdwarf`. So you should\r\ninstall `libdwarf` by `pkg`, and must not install `libelf` by `pkg`.\r\n\r\nAfter all required libraries are installed, run\r\n\r\n    $ ./configure\r\n    $ make\r\n    $ sudo make install\r\n\r\n\r\n## install by package\r\n\r\nThere are also DEB and RPM packages for\r\n[releases] (https://github.com/WuBingzheng/memleax/releases).\r\n\r\n\r\n## usage\r\n\r\n### start\r\n\r\nTo debug a running process, run:\r\n\r\n    $ memleax [options] <target-pid>\r\n\r\nthen `memleax` begins to monitor the target process, and report memory leak in real time.\r\n\r\nYou should always set expire time by `-e` options according to your scenarios.\r\nFor example, if you are debugging an HTTP server with keepalive, and there are\r\nconnections last for more than 5 minutes, you should set `-e 360` to cover it.\r\nIf your program is expected to free every memory in 1 second, you should set `-e 2`\r\nto get report in time.\r\n\r\n### wait and check the report\r\n\r\nThe memory blocks live longer than the threshold, are showed as:\r\n\r\n    CallStack[3]: memory expires with 101 bytes, backtrace:\r\n        0x00007fd322bd8220  libc-2.17.so  malloc()+0\r\n        0x000000000040084e  test  foo()+14  foo.c:12\r\n        0x0000000000400875  test  bar()+37  bar.c:20\r\n        0x0000000000400acb  test  main()+364  test.c:80\r\n\r\n`CallStack[3]` is the ID of CallStack where memory leak happens.\r\n\r\nThe backtrace is showed only on the first time, while it only shows the\r\nID and counter if expiring again:\r\n\r\n    CallStack[3]: memory expires with 101 bytes, 2 times again\r\n\r\nIf the expired memory block is freed later, it shows:\r\n\r\n    CallStack[6]: expired-memory frees after 10 seconds\r\n\r\nIf there are too many expired-memory-blocks are freed on one CallStack,\r\nthis CallStack will not be showed again:\r\n\r\n    Warning: too many expired-free at CallStack[6]. will not show this CallStack later\r\n\r\nWhen you think you have found the answer, stop the debug.\r\n\r\n### stop\r\n\r\n`memleax` quits on:\r\n\r\n* you stop it, by Ctrl-C or kill,\r\n* the target process quits,\r\n* too many leaks at one CallStack (option -m), or\r\n* too many CallStacks with memory leak (option -c).\r\n\r\nAfter quitting, it also gives statistics for the CallStacks with memory leak:\r\n\r\n    CallStack[3]: may-leak=20 (2020 bytes)\r\n        expired=20 (2020 bytes), free_expired=0 (0 bytes)\r\n        alloc=20 (2020 bytes), free=0 (0 bytes)\r\n        freed memory live time: min=0 max=0 average=0\r\n        un-freed memory live time: max=20\r\n        0x00007fd322bd8220  libc-2.17.so  malloc()+0\r\n        0x000000000040084e  test  foo()+14  foo.c:12\r\n        0x0000000000400875  test  bar()+37  bar.c:20\r\n        0x0000000000400acb  test  main()+364  test.c:80\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}