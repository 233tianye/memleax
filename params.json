{
  "name": "Memleax",
  "tagline": "detects memory leak of running process",
  "body": "## memleax\r\n\r\n`memleax` detects memory leak of a *running* process.\r\n\r\n\r\n## why write this\r\n\r\nOnce I met a memory leak problem in production environment.\r\nThe process began memory leak after long-time running. If using current\r\nmemory debuggers, such as `Valgrind`, I have to restart the target process\r\nand wait for several days again. Besides it impacts the target process\r\nmuch for several days, which is not good for production environment.\r\n\r\nSo I need a tool to debug a running process without restarting it.\r\nI searched the internet but didn't find one. Then I wrote such a tool myself.\r\n\r\nHope this is useful for others.\r\n\r\n\r\n## how it works\r\n\r\n`memleax` attachs a running process, hooks memory allocate/free APIs,\r\nrecords all memory blocks, and reports the blocks which live longer\r\nthan 5 seconds (you can change this time by -e option) in real time.\r\n\r\nIt is very *convenient* to use, and suitable for production environment.\r\nThere is no need to recompile the program or restart the target process.\r\nYou run `memleax` to monitor the target process, wait for the real-time memory\r\nleak report, and then kill it (e.g. by Ctrl-C) to stop monitoring.\r\n\r\nNOTE: Since `memleax` does not run along with the whole life of target\r\nprocess, it assumes the long-live memory blocks are memory leak.\r\nDownside is you have to set the expire threshold by -e option according\r\nto your scenarios; while the upside is the memory allocation for process\r\ninitialization is skipped, besides of the convenience.\r\n\r\n\r\n## performace influence\r\n\r\nBecause target progress's each memory allocation/free API invokes a TRAP, the\r\nperformance influence depends on how often the target program calls memory\r\nAPIs.\r\nFor example, it impacts lightly to nginx with HTTP, while heavily with HTTPS,\r\nbecause OpenSSL calls malloc seriously.\r\n\r\nAlthough performance influence is worthy of consideration, since `memleax` is\r\nrun to attach the target progress only when you certain it is in memory leak,\r\nand stopped after real-time memory leak report, so it is not need to attach\r\nthe target progress for long time.\r\n\r\n\r\n## difference with Valgrind\r\n\r\n+ `Valgrind` starts target process, while `memleax` attachs a running process;\r\n\r\n+ `Valgrind` gives memory leak report on quiting, while `memleax` assumes\r\nthat long-living memory blocks are leaks, so it reports in real time;\r\n\r\n+ `Valgrind` runs target process on its virtual CPU, which makes it slow.\r\nWhile `memleax` hooks memory APIs, which *maybe* less slow, if the target process\r\ncall memory APIs not often.\r\n\r\n+ `Valgrind` debugs kinds of memory bugs, while `memleax` is lightweight and\r\nonly detects memory leak.\r\n\r\nIn summary, I think `Valgrind` is more powerful, while `memleax` is more\r\nconvenient and suitable for production environment.\r\n\r\n\r\n## environment\r\n\r\n+ GNU/Linux, x86_64\r\n+ FreeBSD, amd64\r\n\r\n\r\n## requirement\r\n\r\n+ libunwind\r\n+ libdwarf, if you do not have this, set `--disable-libdwarf` to `configure` to\r\n  disable it, and you will not see file name and line number in backtrace.\r\n+ elfutils-libelf, on GNU/Linux, while FreeBSD has libelf already.\r\n\r\n\r\n## usage\r\n\r\nTo detect a running process:\r\n\r\n    $ memleax [options] <target-pid>\r\n\r\nthen `memleax` monitors the target process, and will report memory leak in real time.\r\n\r\nIt stops monitoring and quits on:\r\n\r\n* the target process quits,\r\n* `memleax` exits (by SIGKILL or Ctrl-C), or\r\n* the number of leaked memory blocks at one CallStack exceeds 1000 (change this threshold by -n option).\r\n\r\nAfter quiting, it also gives statistics for the CallStacks with memory leak.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}